   1              	# 1 "../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S"
   1              	/*
   0              	
   2              	 * File      : context_gcc.S
   0              	
   3              	 * This file is part of RT-Thread RTOS
   4              	 * COPYRIGHT (C) 2009, RT-Thread Development Team
   5              	 *
   6              	 * The license and distribution terms for this file may be
   7              	 * found in the file LICENSE in this distribution or at
   8              	 * http://www.rt-thread.org/license/LICENSE
   9              	 *
  10              	 * Change Logs:
  11              	 * Date           Author       Notes
  12              	 * 2009-10-11     Bernard      first version
  13              	 * 2012-01-01     aozima       support context switch load/store FPU register.
  14              	 */
  15              	
  16              	/**
  17              	 * @addtogroup STM32
  18              	 */
  19              	/*@{*/
  20              	
  21              	.cpu cortex-m4
  22              	.syntax unified
  23              	.thumb
  24              	.text
  25              	
  26              	.equ    NVIC_INT_CTRL,       0xE000ED04               /* interrupt control state register */
  27              	.equ    NVIC_SYSPRI2,        0xE000ED20               /* system priority register (2) */
  28              	.equ    NVIC_PENDSV_PRI,     0x00FF0000               /* PendSV priority value (lowest) */
  29              	.equ    NVIC_PENDSVSET,      0x10000000               /* value to trigger PendSV exception */
  30              	
  31              	/*
  32              	 * rt_base_t rt_hw_interrupt_disable();
  33              	 */
  34              	.global rt_hw_interrupt_disable
  36              	rt_hw_interrupt_disable:
  37 0000 EFF31080 	    MRS     r0, PRIMASK
  38 0004 72B6     	    CPSID   I
  39 0006 7047     	    BX      LR
  40              	
  41              	/*
  42              	 * void rt_hw_interrupt_enable(rt_base_t level);
  43              	 */
  44              	.global rt_hw_interrupt_enable
  46              	rt_hw_interrupt_enable:
  47 0008 80F31088 	    MSR     PRIMASK, r0
  48 000c 7047     	    BX      LR
  49              	
  50              	/*
  51              	 * void rt_hw_context_switch(rt_uint32 from, rt_uint32 to);
  52              	 * r0 --> from
  53              	 * r1 --> to
  54              	 */
  55              	.global rt_hw_context_switch_interrupt
  57              	.global rt_hw_context_switch
  59              	
  60              	rt_hw_context_switch_interrupt:
  61              	rt_hw_context_switch:
  62              	    /* set rt_thread_switch_interrupt_flag to 1 */
  63 000e 274A     	    LDR     r2, =rt_thread_switch_interrupt_flag
  64 0010 1368     	    LDR     r3, [r2]
  65 0012 012B     	    CMP     r3, #1
  66 0014 00F00580 	    BEQ     _reswitch
  67 0018 4FF00103 	    MOV     r3, #1
  68 001c 1360     	    STR     r3, [r2]
  69              	
  70 001e 244A     	    LDR     r2, =rt_interrupt_from_thread   /* set rt_interrupt_from_thread */
  71 0020 1060     	    STR     r0, [r2]
  72              	
  73              	_reswitch:
  74 0022 244A     	    LDR     r2, =rt_interrupt_to_thread     /* set rt_interrupt_to_thread */
  75 0024 1160     	    STR     r1, [r2]
  76              	
  77 0026 2448     	    LDR r0, =NVIC_INT_CTRL              /* trigger the PendSV exception (causes context switch) */
  78 0028 2449     	    LDR r1, =NVIC_PENDSVSET
  79 002a 0160     	    STR r1, [r0]
  80 002c 7047     	    BX  LR
  81              	
  82              	/* r0 --> swith from thread stack
  83              	 * r1 --> swith to thread stack
  84              	 * psr, pc, lr, r12, r3, r2, r1, r0 are pushed into [from] stack
  85              	 */
  86              	.global PendSV_Handler
  88              	PendSV_Handler:
  89              	    /* disable interrupt to protect context switch */
  90 002e EFF31082 	    MRS r2, PRIMASK
  91 0032 72B6     	    CPSID   I
  92              	
  93              	    /* get rt_thread_switch_interrupt_flag */
  94 0034 1D48     	    LDR r0, =rt_thread_switch_interrupt_flag
  95 0036 0168     	    LDR r1, [r0]
  96 0038 91B1     	    CBZ r1, pendsv_exit         /* pendsv already handled */
  97              	
  98              	    /* clear rt_thread_switch_interrupt_flag to 0 */
  99 003a 4FF00001 	    MOV r1, #0x00
 100 003e 0160     	    STR r1, [r0]
 101              	
 102 0040 1B48     	    LDR r0, =rt_interrupt_from_thread
 103 0042 0168     	    LDR r1, [r0]
 104 0044 29B1     	    CBZ r1, swtich_to_thread    /* skip register save at the first time */
 105              	
 106 0046 EFF30981 	    MRS r1, psp                 /* get from thread stack pointer */
 107              	    
 108              	#if defined (__VFP_FP__) && !defined(__SOFTFP__)
 109              		VSTMDB  r1!, {d8 - d15}     /* push FPU register s16~s31 */
 110              	#endif
 111              		
 112 004a 21E9F00F 	    STMFD   r1!, {r4 - r11}     /* push r4 - r11 register */
 113 004e 0068     	    LDR r0, [r0]
 114 0050 0160     	    STR r1, [r0]                /* update from thread stack pointer */
 115              	
 116              	swtich_to_thread:
 117 0052 1849     	    LDR r1, =rt_interrupt_to_thread
 118 0054 0968     	    LDR r1, [r1]
 119 0056 0968     	    LDR r1, [r1]                /* load thread stack pointer */
 120              	
 121 0058 B1E8F00F 	    LDMFD   r1!, {r4 - r11}     /* pop r4 - r11 register */
 122              	
 123              	#if defined (__VFP_FP__) && !defined(__SOFTFP__)
 124              	    VLDMIA  r1!, {d8 - d15}     /* pop FPU register s16~s31 */
 125              	#endif
 126              	
 127 005c 81F30988 	    MSR psp, r1                 /* update stack pointer */
 128              	
 129              	pendsv_exit:
 130              	    /* restore interrupt */
 131 0060 82F31088 	    MSR PRIMASK, r2
 132              	
 133 0064 4EF0040E 	    ORR lr, lr, #0x04
 134 0068 7047     	    BX  lr
 135              	
 136              	/*
 137              	 * void rt_hw_context_switch_to(rt_uint32 to);
 138              	 * r0 --> to
 139              	 */
 140              	.global rt_hw_context_switch_to
 142              	rt_hw_context_switch_to:
 143 006a 1249     	    LDR r1, =rt_interrupt_to_thread
 144 006c 0860     	    STR r0, [r1]
 145              	
 146              	    /* set from thread to 0 */
 147 006e 1049     	    LDR r1, =rt_interrupt_from_thread
 148 0070 4FF00000 	    MOV r0, #0x0
 149 0074 0860     	    STR r0, [r1]
 150              	
 151              	    /* set interrupt flag to 1 */
 152 0076 0D49     	    LDR     r1, =rt_thread_switch_interrupt_flag
 153 0078 4FF00100 	    MOV     r0, #1
 154 007c 0860     	    STR     r0, [r1]
 155              	
 156              	    /* set the PendSV exception priority */
 157 007e 1048     	    LDR r0, =NVIC_SYSPRI2
 158 0080 1049     	    LDR r1, =NVIC_PENDSV_PRI
 159 0082 D0F80020 	    LDR.W   r2, [r0,#0x00]       /* read       */
 160 0086 41EA0201 	    ORR     r1,r1,r2             /* modify     */
 161 008a 0160     	    STR     r1, [r0]             /* write-back */
 162              	
 163 008c 0A48     	    LDR r0, =NVIC_INT_CTRL      /* trigger the PendSV exception (causes context switch) */
 164 008e 0B49     	    LDR r1, =NVIC_PENDSVSET
 165 0090 0160     	    STR r1, [r0]
 166              	
 167 0092 62B6     	    CPSIE   I                       /* enable interrupts at processor level */
 168              	
 169              	    /* never reach here! */
 170              	
 171              	/* compatible with old version */
 172              	.global rt_hw_interrupt_thread_switch
 174              	rt_hw_interrupt_thread_switch:
 175 0094 7047     	    BX  lr
 176 0096 00BF     	    NOP
 177              	
 178              	.global HardFault_Handler
 180              	HardFault_Handler:
 181              	    /* get current context */
 182 0098 EFF30980 	    MRS     r0, psp                 /* get fault thread stack pointer */
 183 009c 00B5     	    PUSH    {lr}
 184 009e FFF7FEFF 	    BL      rt_hw_hard_fault_exception
 185 00a2 5DF804EB 	    POP     {lr}
 186              	
 187 00a6 4EF0040E 	    ORR     lr, lr, #0x04
 188 00aa 70470000 	    BX      lr
 188      00000000 
 188      00000000 
 188      000004ED 
 188      00E00000 
DEFINED SYMBOLS
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:26     *ABS*:e000ed04 NVIC_INT_CTRL
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:27     *ABS*:e000ed20 NVIC_SYSPRI2
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:28     *ABS*:00ff0000 NVIC_PENDSV_PRI
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:29     *ABS*:10000000 NVIC_PENDSVSET
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:36     .text:00000000 rt_hw_interrupt_disable
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:37     .text:00000000 $t
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:46     .text:00000008 rt_hw_interrupt_enable
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:60     .text:0000000e rt_hw_context_switch_interrupt
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:61     .text:0000000e rt_hw_context_switch
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:73     .text:00000022 _reswitch
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:88     .text:0000002e PendSV_Handler
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:129    .text:00000060 pendsv_exit
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:116    .text:00000052 swtich_to_thread
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:142    .text:0000006a rt_hw_context_switch_to
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:174    .text:00000094 rt_hw_interrupt_thread_switch
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:180    .text:00000098 HardFault_Handler
../src/os/rt-thread/libcpu/arm/cortex-m4/context_gcc.S:188    .text:000000ac $d
                   .debug_aranges:0000000c $d

UNDEFINED SYMBOLS
rt_thread_switch_interrupt_flag
rt_interrupt_from_thread
rt_interrupt_to_thread
rt_hw_hard_fault_exception
